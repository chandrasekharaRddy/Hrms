{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport CanvasJSObject from './canvasjs';\nimport { extend, getProperty } from '../helpers/utils';\nfunction DataSeries(chart, options, theme, index, id) {\n  DataSeries.base.constructor.call(this, \"DataSeries\", options, theme);\n  this.chart = chart;\n  this.canvas = chart.canvas;\n  this._ctx = chart.canvas.ctx;\n  this.index = index;\n  this.noDataPointsInPlotArea = 0;\n  //this.maxWidthInX = 0;\n  this.id = id;\n  this.chart._eventManager.objectMap[id] = {\n    id: id,\n    objectType: \"dataSeries\",\n    dataSeriesIndex: index\n  };\n  this.dataPointIds = [];\n  this.plotUnit = [];\n  this.axisX = null;\n  this.axisY = null;\n  if (this.fillOpacity === null) {\n    if (this.type.match(/area/i)) this.fillOpacity = .7;else this.fillOpacity = 1;\n  }\n  this.axisPlacement = this.getDefaultAxisPlacement();\n  if (typeof this._options.indexLabelFontSize === \"undefined\") {\n    this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize);\n  }\n}\nextend(DataSeries, CanvasJSObject);\n\n//Static Method that returns the axisPlacement for a given ChartType. Returns one of \"normal\", \"xySwapped\", \"none\"\nDataSeries.prototype.getDefaultAxisPlacement = function () {\n  //if (!this.visible)\n  //\treturn \"none\";\n\n  //type = this.type.toLowerCase();\n  var type = this.type;\n  if (type === \"column\" || type === \"line\" || type === \"stepLine\" || type === \"spline\" || type === \"area\" || type === \"stepArea\" || type === \"splineArea\" || type === \"stackedColumn\" || type === \"stackedLine\" || type === \"bubble\" || type === \"scatter\" || type === \"stackedArea\" || type === \"stackedColumn100\" || type === \"stackedLine100\" || type === \"stackedArea100\" || type === \"candlestick\" || type === \"ohlc\" || type === \"rangeColumn\" || type === \"rangeArea\" || type === \"rangeSplineArea\") {\n    return \"normal\";\n  } else if (type === \"bar\" || type === \"stackedBar\" || type === \"stackedBar100\" || type === \"rangeBar\") {\n    return \"xySwapped\";\n  } else if (type === \"pie\" || type === \"doughnut\" || type === \"funnel\") {\n    return \"none\";\n  } else {\n    window.console.log(\"Unknown Chart Type: \" + type);\n    return null;\n  }\n};\nDataSeries.getDefaultLegendMarker = function (type) {\n  //type = type.toLowerCase();\n\n  if (type === \"column\" || type === \"stackedColumn\" || type === \"stackedLine\" || type === \"bar\" || type === \"stackedBar\" || type === \"stackedBar100\" || type === \"bubble\" || type === \"scatter\" || type === \"stackedColumn100\" || type === \"stackedLine100\" || type === \"stepArea\" || type === \"candlestick\" || type === \"ohlc\" || type === \"rangeColumn\" || type === \"rangeBar\" || type === \"rangeArea\" || type === \"rangeSplineArea\") {\n    return \"square\";\n  } else if (type === \"line\" || type === \"stepLine\" || type === \"spline\" || type === \"pie\" || type === \"doughnut\" || type === \"funnel\") {\n    return \"circle\";\n  } else if (type === \"area\" || type === \"splineArea\" || type === \"stackedArea\" || type === \"stackedArea100\") {\n    return \"triangle\";\n  } else {\n    window.console.log(\"Unknown Chart Type: \" + type);\n    return null;\n  }\n};\n\n//Finds dataPoint with the given x value. If findClosest is set, finds dataPoint with closest x value.\n//Returns searchResult object if found, else returns null\nDataSeries.prototype.getDataPointAtX = function (x, findClosest) {\n  if (!this.dataPoints || this.dataPoints.length === 0) return null;\n  var searchResult = {\n    dataPoint: null,\n    distance: Infinity,\n    index: NaN\n  };\n  var dataPoint = null;\n  var j = 0;\n  var i = 0;\n  var direction = 1; // +1 for foward and -1 for backward.\n\n  var minimumXDistance = Infinity;\n  var forwardMissCount = 0,\n    backwardMissCount = 0;\n  var maxMissCount = 1000;\n  var searchStartIndex = 0;\n  if (this.chart.plotInfo.axisPlacement !== \"none\") {\n    //var xRange = (this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x);\n\n    //if (xRange > 0)\n    //\tsearchStartIndex = ((this.dataPoints.length - 1) / xRange * (x - this.dataPoints[0].x)) >> 0;\n    //else\n    //\tsearchStartIndex = 0;\n\n    var xRange = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x;\n    if (xRange > 0) searchStartIndex = Math.min(Math.max((this.dataPoints.length - 1) / xRange * (x - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length);else searchStartIndex = 0;\n\n    //searchStartIndex = ((this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x) / this.dataPoints.length * (x - this.dataPoints[0].x)) >> 0;\n  }\n  while (true) {\n    i = direction > 0 ? searchStartIndex + j : searchStartIndex - j;\n    if (i >= 0 && i < this.dataPoints.length) {\n      dataPoint = this.dataPoints[i];\n      var distance = Math.abs(dataPoint.x - x);\n      if (distance < searchResult.distance) {\n        searchResult.dataPoint = dataPoint;\n        searchResult.distance = distance;\n        searchResult.index = i;\n      }\n      var xDistance = Math.abs(dataPoint.x - x);\n      if (xDistance <= minimumXDistance) minimumXDistance = xDistance;else {\n        if (direction > 0) forwardMissCount++;else backwardMissCount++;\n      }\n      if (forwardMissCount > maxMissCount && backwardMissCount > maxMissCount) break;\n    } else if (searchStartIndex - j < 0 && searchStartIndex + j >= this.dataPoints.length) break;\n    if (direction === -1) {\n      j++;\n      direction = 1;\n    } else direction = -1;\n  }\n  if (!findClosest && searchResult.dataPoint.x === x) return searchResult;else if (findClosest && searchResult.dataPoint !== null) return searchResult;else return null;\n};\n\n// x & y should be in pixels. Can be used only after rendering the chart.\nDataSeries.prototype.getDataPointAtXY = function (x, y, getClosest) {\n  if (!this.dataPoints || this.dataPoints.length === 0) return null;\n  getClosest = getClosest || false;\n  var results = [];\n  var j = 0,\n    i = 0;\n  var direction = 1; // +1 for foward and -1 for backward.\n  var foundDataPoint = false;\n  var minimumXDistance = Infinity;\n  var forwardMissCount = 0,\n    backwardMissCount = 0;\n  var maxMissCount = 1000;\n  var searchStartIndex = 0;\n  if (this.chart.plotInfo.axisPlacement !== \"none\") {\n    var xval = this.chart.axisX.getXValueAt({\n      x: x,\n      y: y\n    });\n    var xRange = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x;\n    if (xRange > 0) searchStartIndex = Math.min(Math.max((this.dataPoints.length - 1) / xRange * (xval - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length);else searchStartIndex = 0;\n\n    //var xRange = (this.axisX._absoluteMaximum - this.axisX._absoluteMinimum);\n\n    //if (xRange > 0)\n    //\tsearchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * (xval - this.axisX._absoluteMinimum)) >> 0, 0), this.dataPoints.length);\n    //else\n    //\tsearchStartIndex = 0;\n  }\n  while (true) {\n    //i = searchStartIndex + (j * direction);\n    i = direction > 0 ? searchStartIndex + j : searchStartIndex - j;\n    if (i >= 0 && i < this.dataPoints.length) {\n      var id = this.dataPointIds[i];\n      var visualInfo = this.chart._eventManager.objectMap[id];\n      var dataPoint = this.dataPoints[i];\n      var distance = null;\n      if (visualInfo) {\n        switch (this.type) {\n          case \"column\":\n          case \"stackedColumn\":\n          case \"stackedColumn100\":\n          case \"bar\":\n          case \"stackedBar\":\n          case \"stackedBar100\":\n          case \"rangeColumn\":\n          case \"rangeBar\":\n            if (x >= visualInfo.x1 && x <= visualInfo.x2 && y >= visualInfo.y1 && y <= visualInfo.y2) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y1 - y), Math.abs(visualInfo.y2 - y))\n                //distance:0\n              });\n              foundDataPoint = true;\n            }\n            break;\n          case \"line\":\n          case \"stepLine\":\n          case \"spline\":\n          case \"area\":\n          case \"stepArea\":\n          case \"stackedArea\":\n          case \"stackedArea100\":\n          case \"splineArea\":\n          case \"scatter\":\n            var markerSize = getProperty(\"markerSize\", dataPoint, this) || 4;\n            var snapDistance = getClosest ? 20 : markerSize;\n            distance = Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2));\n            if (distance <= snapDistance) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: distance\n              });\n            }\n            var xDistance = Math.abs(visualInfo.x1 - x);\n            if (xDistance <= minimumXDistance) minimumXDistance = xDistance;else {\n              if (direction > 0) forwardMissCount++;else backwardMissCount++;\n            }\n            if (distance <= markerSize / 2) {\n              foundDataPoint = true;\n            }\n            break;\n          case \"rangeArea\":\n          case \"rangeSplineArea\":\n            var markerSize = getProperty(\"markerSize\", dataPoint, this) || 4;\n            var snapDistance = getClosest ? 20 : markerSize;\n            distance = Math.min(Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2)), Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y2 - y, 2)));\n            if (distance <= snapDistance) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: distance\n              });\n            }\n            var xDistance = Math.abs(visualInfo.x1 - x);\n            if (xDistance <= minimumXDistance) minimumXDistance = xDistance;else {\n              if (direction > 0) forwardMissCount++;else backwardMissCount++;\n            }\n            if (distance <= markerSize / 2) {\n              foundDataPoint = true;\n            }\n            break;\n          case \"bubble\":\n            var markerSize = visualInfo.size;\n            distance = Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2));\n            if (distance <= markerSize / 2) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: distance\n              });\n              foundDataPoint = true;\n            }\n            break;\n          case \"pie\":\n          case \"doughnut\":\n            var center = visualInfo.center;\n            var innerRadius = this.type === \"doughnut\" ? visualInfo.percentInnerRadius * visualInfo.radius : 0;\n            distance = Math.sqrt(Math.pow(center.x - x, 2) + Math.pow(center.y - y, 2));\n            if (distance < visualInfo.radius && distance > innerRadius) {\n              var deltaY = y - center.y;\n              var deltaX = x - center.x;\n              var angle = Math.atan2(deltaY, deltaX);\n              if (angle < 0) angle += Math.PI * 2;\n              angle = Number(((angle / Math.PI * 180 % 360 + 360) % 360).toFixed(12));\n              //console.log(angle);\n\n              var startAngle = Number(((visualInfo.startAngle / Math.PI * 180 % 360 + 360) % 360).toFixed(12));\n              var endAngle = Number(((visualInfo.endAngle / Math.PI * 180 % 360 + 360) % 360).toFixed(12));\n\n              //So that data point is detected when there is only one dataPoint\n              if (endAngle === 0 && visualInfo.endAngle > 1) {\n                endAngle = 360;\n              }\n              if (startAngle >= endAngle && dataPoint.y !== 0) {\n                endAngle += 360;\n                if (angle < startAngle) angle += 360;\n              }\n              if (angle > startAngle && angle < endAngle) {\n                results.push({\n                  dataPoint: dataPoint,\n                  dataPointIndex: i,\n                  dataSeries: this,\n                  distance: 0\n                });\n                foundDataPoint = true;\n              }\n            }\n            break;\n          case \"candlestick\":\n            if (x >= visualInfo.x1 - visualInfo.borderThickness / 2 && x <= visualInfo.x2 + visualInfo.borderThickness / 2 && y >= visualInfo.y2 - visualInfo.borderThickness / 2 && y <= visualInfo.y3 + visualInfo.borderThickness / 2 || Math.abs(visualInfo.x2 - x + visualInfo.x1 - x) < visualInfo.borderThickness && y >= visualInfo.y1 && y <= visualInfo.y4) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y2 - y), Math.abs(visualInfo.y3 - y))\n                //distance:0\n              });\n              foundDataPoint = true;\n            }\n            break;\n          case \"ohlc\":\n            if (Math.abs(visualInfo.x2 - x + visualInfo.x1 - x) < visualInfo.borderThickness && y >= visualInfo.y2 && y <= visualInfo.y3 || x >= visualInfo.x1 && x <= (visualInfo.x2 + visualInfo.x1) / 2 && y >= visualInfo.y1 - visualInfo.borderThickness / 2 && y <= visualInfo.y1 + visualInfo.borderThickness / 2 || x >= (visualInfo.x1 + visualInfo.x2) / 2 && x <= visualInfo.x2 && y >= visualInfo.y4 - visualInfo.borderThickness / 2 && y <= visualInfo.y4 + visualInfo.borderThickness / 2) {\n              results.push({\n                dataPoint: dataPoint,\n                dataPointIndex: i,\n                dataSeries: this,\n                distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y2 - y), Math.abs(visualInfo.y3 - y))\n                //distance:0\n              });\n              foundDataPoint = true;\n            }\n            break;\n        }\n        if (foundDataPoint || forwardMissCount > maxMissCount && backwardMissCount > maxMissCount) break;\n      }\n    } else if (searchStartIndex - j < 0 && searchStartIndex + j >= this.dataPoints.length) break;\n    if (direction === -1) {\n      j++;\n      direction = 1;\n    } else direction = -1;\n  }\n  var closestResult = null;\n  for (var m = 0; m < results.length; m++) {\n    if (!closestResult) {\n      closestResult = results[m];\n    } else if (results[m].distance <= closestResult.distance) {\n      closestResult = results[m];\n    }\n  }\n\n  //if (window.console)\n  //\twindow.console.log(\"forwardMissCount: \" + forwardMissCount + \"; backwardMissCount: \" + backwardMissCount + \"; getClosest: \" + getClosest);\n\n  //if (window.console && closestResult)\n  //    window.console.log(j + \": distance = \" + closestResult.distance);\n\n  return closestResult;\n};\nDataSeries.prototype.getMarkerProperties = function (index, x, y, ctx) {\n  var dataPoints = this.dataPoints;\n  var dataSeries = this;\n  var markerColor = dataPoints[index].markerColor ? dataPoints[index].markerColor : dataSeries.markerColor ? dataSeries.markerColor : dataPoints[index].color ? dataPoints[index].color : dataSeries.color ? dataSeries.color : dataSeries._colorSet[index % dataSeries._colorSet.length];\n  var markerBorderColor = dataPoints[index].markerBorderColor ? dataPoints[index].markerBorderColor : dataSeries.markerBorderColor ? dataSeries.markerBorderColor : null;\n  var markerBorderThickness = dataPoints[index].markerBorderThickness ? dataPoints[index].markerBorderThickness : dataSeries.markerBorderThickness ? dataSeries.markerBorderThickness : null;\n  var markerType = dataPoints[index].markerType ? dataPoints[index].markerType : dataSeries.markerType;\n  var markerSize = dataPoints[index].markerSize ? dataPoints[index].markerSize : dataSeries.markerSize;\n  return {\n    x: x,\n    y: y,\n    ctx: ctx,\n    type: markerType,\n    size: markerSize,\n    color: markerColor,\n    borderColor: markerBorderColor,\n    borderThickness: markerBorderThickness\n  };\n};\nexport default DataSeries;","map":{"version":3,"names":["CanvasJSObject","extend","getProperty","DataSeries","chart","options","theme","index","id","base","constructor","call","canvas","_ctx","ctx","noDataPointsInPlotArea","_eventManager","objectMap","objectType","dataSeriesIndex","dataPointIds","plotUnit","axisX","axisY","fillOpacity","type","match","axisPlacement","getDefaultAxisPlacement","_options","indexLabelFontSize","getAutoFontSize","prototype","window","console","log","getDefaultLegendMarker","getDataPointAtX","x","findClosest","dataPoints","length","searchResult","dataPoint","distance","Infinity","NaN","j","i","direction","minimumXDistance","forwardMissCount","backwardMissCount","maxMissCount","searchStartIndex","plotInfo","xRange","Math","min","max","abs","xDistance","getDataPointAtXY","y","getClosest","results","foundDataPoint","xval","getXValueAt","visualInfo","x1","x2","y1","y2","push","dataPointIndex","dataSeries","markerSize","snapDistance","sqrt","pow","size","center","innerRadius","percentInnerRadius","radius","deltaY","deltaX","angle","atan2","PI","Number","toFixed","startAngle","endAngle","borderThickness","y3","y4","closestResult","m","getMarkerProperties","markerColor","color","_colorSet","markerBorderColor","markerBorderThickness","markerType","borderColor"],"sources":["C:/Users/IMPEGNOABS010/Desktop/HRMSROUT/node_modules/canvasjs/src/core/data_series.js"],"sourcesContent":["\r\nimport CanvasJSObject from './canvasjs';\r\nimport {extend, getProperty} from '../helpers/utils';\r\n\r\nfunction DataSeries(chart, options, theme, index, id) {\r\n  DataSeries.base.constructor.call(this, \"DataSeries\", options, theme);\r\n\r\n  this.chart = chart;\r\n  this.canvas = chart.canvas;\r\n  this._ctx = chart.canvas.ctx;\r\n  this.index = index;\r\n  this.noDataPointsInPlotArea = 0;\r\n  //this.maxWidthInX = 0;\r\n  this.id = id;\r\n  this.chart._eventManager.objectMap[id] = {\r\n    id: id, objectType: \"dataSeries\", dataSeriesIndex: index\r\n  }\r\n  this.dataPointIds = [];\r\n  this.plotUnit = [];\r\n\r\n  this.axisX = null;\r\n  this.axisY = null;\r\n\r\n  if (this.fillOpacity === null) {\r\n    if (this.type.match(/area/i))\r\n      this.fillOpacity = .7;\r\n    else\r\n      this.fillOpacity = 1;\r\n  }\r\n\r\n\r\n  this.axisPlacement = this.getDefaultAxisPlacement();\r\n\r\n  if (typeof (this._options.indexLabelFontSize) === \"undefined\") {\r\n\r\n    this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize);\r\n  }\r\n}\r\n\r\nextend(DataSeries, CanvasJSObject);\r\n\r\n//Static Method that returns the axisPlacement for a given ChartType. Returns one of \"normal\", \"xySwapped\", \"none\"\r\nDataSeries.prototype.getDefaultAxisPlacement = function () {\r\n\r\n  //if (!this.visible)\r\n  //\treturn \"none\";\r\n\r\n  //type = this.type.toLowerCase();\r\n  var type = this.type;\r\n\r\n  if (type === \"column\" || type === \"line\" || type === \"stepLine\" || type === \"spline\" || type === \"area\" || type === \"stepArea\" || type === \"splineArea\" || type === \"stackedColumn\" || type === \"stackedLine\" || type === \"bubble\" || type === \"scatter\"\r\n    || type === \"stackedArea\" || type === \"stackedColumn100\" || type === \"stackedLine100\" || type === \"stackedArea100\"\r\n    || type === \"candlestick\" || type === \"ohlc\" || type === \"rangeColumn\" || type === \"rangeArea\" || type === \"rangeSplineArea\") {\r\n    return \"normal\";\r\n  }\r\n  else if (type === \"bar\" || type === \"stackedBar\" || type === \"stackedBar100\" || type === \"rangeBar\") {\r\n\r\n    return \"xySwapped\";\r\n  }\r\n  else if (type === \"pie\" || type === \"doughnut\" || type === \"funnel\") {\r\n    return \"none\";\r\n  } else {\r\n    window.console.log(\"Unknown Chart Type: \" + type);\r\n    return null;\r\n  }\r\n}\r\n\r\nDataSeries.getDefaultLegendMarker = function (type) {\r\n\r\n  //type = type.toLowerCase();\r\n\r\n  if (type === \"column\" || type === \"stackedColumn\" || type === \"stackedLine\" || type === \"bar\" || type === \"stackedBar\" || type === \"stackedBar100\"\r\n    || type === \"bubble\" || type === \"scatter\"\r\n    || type === \"stackedColumn100\" || type === \"stackedLine100\" || type === \"stepArea\"\r\n    || type === \"candlestick\" || type === \"ohlc\" || type === \"rangeColumn\" || type === \"rangeBar\" || type === \"rangeArea\" || type === \"rangeSplineArea\") {\r\n    return \"square\";\r\n  }\r\n  else if (type === \"line\" || type === \"stepLine\" || type === \"spline\" || type === \"pie\" || type === \"doughnut\" || type === \"funnel\") {\r\n    return \"circle\";\r\n  } else if (type === \"area\" || type === \"splineArea\" || type === \"stackedArea\" || type === \"stackedArea100\") {\r\n    return \"triangle\"\r\n  } else {\r\n    window.console.log(\"Unknown Chart Type: \" + type);\r\n    return null;\r\n  }\r\n}\r\n\r\n//Finds dataPoint with the given x value. If findClosest is set, finds dataPoint with closest x value.\r\n//Returns searchResult object if found, else returns null\r\nDataSeries.prototype.getDataPointAtX = function (x, findClosest) {\r\n\r\n  if (!this.dataPoints || this.dataPoints.length === 0) return null;\r\n\r\n  var searchResult = {\r\n    dataPoint: null, distance: Infinity, index: NaN\r\n  };\r\n  var dataPoint = null;\r\n\r\n  var j = 0;\r\n  var i = 0;\r\n  var direction = 1; // +1 for foward and -1 for backward.\r\n\r\n  var minimumXDistance = Infinity;\r\n  var forwardMissCount = 0, backwardMissCount = 0;\r\n  var maxMissCount = 1000;\r\n  var searchStartIndex = 0;\r\n\r\n  if (this.chart.plotInfo.axisPlacement !== \"none\") {\r\n\r\n    //var xRange = (this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x);\r\n\r\n    //if (xRange > 0)\r\n    //\tsearchStartIndex = ((this.dataPoints.length - 1) / xRange * (x - this.dataPoints[0].x)) >> 0;\r\n    //else\r\n    //\tsearchStartIndex = 0;\r\n\r\n    var xRange = (this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x);\r\n\r\n    if (xRange > 0)\r\n      searchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * (x - this.dataPoints[0].x)) >> 0, 0), this.dataPoints.length);\r\n    else\r\n      searchStartIndex = 0;\r\n\r\n    //searchStartIndex = ((this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x) / this.dataPoints.length * (x - this.dataPoints[0].x)) >> 0;\r\n  }\r\n\r\n  while (true) {\r\n\r\n    i = (direction > 0) ? searchStartIndex + j : searchStartIndex - j;\r\n\r\n    if (i >= 0 && i < this.dataPoints.length) {\r\n\r\n      dataPoint = this.dataPoints[i];\r\n\r\n      var distance = Math.abs(dataPoint.x - x);\r\n\r\n      if (distance < searchResult.distance) {\r\n        searchResult.dataPoint = dataPoint;\r\n        searchResult.distance = distance;\r\n        searchResult.index = i;\r\n      }\r\n\r\n      var xDistance = Math.abs(dataPoint.x - x);\r\n      if (xDistance <= minimumXDistance)\r\n        minimumXDistance = xDistance;\r\n      else {\r\n        if (direction > 0)\r\n          forwardMissCount++;\r\n        else\r\n          backwardMissCount++;\r\n      }\r\n\r\n      if (forwardMissCount > maxMissCount && backwardMissCount > maxMissCount)\r\n        break;\r\n\r\n\r\n    } else if (searchStartIndex - j < 0 && searchStartIndex + j >= this.dataPoints.length)\r\n      break;\r\n\r\n    if (direction === -1) {\r\n      j++;\r\n      direction = 1;\r\n    } else\r\n      direction = -1;\r\n  }\r\n\r\n\r\n  if (!findClosest && searchResult.dataPoint.x === x)\r\n    return searchResult;\r\n  else if (findClosest && searchResult.dataPoint !== null)\r\n    return searchResult;\r\n  else\r\n    return null;\r\n}\r\n\r\n// x & y should be in pixels. Can be used only after rendering the chart.\r\nDataSeries.prototype.getDataPointAtXY = function (x, y, getClosest) {\r\n\r\n  if (!this.dataPoints || this.dataPoints.length === 0) return null;\r\n\r\n  getClosest = getClosest || false;\r\n  var results = [];\r\n  var j = 0, i = 0;\r\n  var direction = 1; // +1 for foward and -1 for backward.\r\n  var foundDataPoint = false;\r\n  var minimumXDistance = Infinity;\r\n  var forwardMissCount = 0, backwardMissCount = 0;\r\n  var maxMissCount = 1000;\r\n  var searchStartIndex = 0;\r\n\r\n  if (this.chart.plotInfo.axisPlacement !== \"none\") {\r\n    var xval = this.chart.axisX.getXValueAt({ x: x, y: y });\r\n\r\n    var xRange = (this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x);\r\n\r\n    if (xRange > 0)\r\n      searchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * (xval - this.dataPoints[0].x)) >> 0, 0), this.dataPoints.length);\r\n    else\r\n      searchStartIndex = 0;\r\n\r\n    //var xRange = (this.axisX._absoluteMaximum - this.axisX._absoluteMinimum);\r\n\r\n    //if (xRange > 0)\r\n    //\tsearchStartIndex = Math.min(Math.max(((this.dataPoints.length - 1) / xRange * (xval - this.axisX._absoluteMinimum)) >> 0, 0), this.dataPoints.length);\r\n    //else\r\n    //\tsearchStartIndex = 0;\r\n  }\r\n\r\n  while (true) {\r\n\r\n    //i = searchStartIndex + (j * direction);\r\n    i = (direction > 0) ? searchStartIndex + j : searchStartIndex - j;\r\n\r\n    if (i >= 0 && i < this.dataPoints.length) {\r\n\r\n      var id = this.dataPointIds[i];\r\n      var visualInfo = this.chart._eventManager.objectMap[id];\r\n      var dataPoint = this.dataPoints[i];\r\n      var distance = null;\r\n\r\n      if (visualInfo) {\r\n\r\n        switch (this.type) {\r\n\r\n          case \"column\":\r\n          case \"stackedColumn\":\r\n          case \"stackedColumn100\":\r\n          case \"bar\":\r\n          case \"stackedBar\":\r\n          case \"stackedBar100\":\r\n          case \"rangeColumn\":\r\n          case \"rangeBar\":\r\n\r\n            if (x >= visualInfo.x1 && x <= visualInfo.x2 && y >= visualInfo.y1 && y <= visualInfo.y2) {\r\n              results.push({\r\n                dataPoint: dataPoint,\r\n                dataPointIndex: i,\r\n                dataSeries: this,\r\n                distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y1 - y), Math.abs(visualInfo.y2 - y))\r\n                //distance:0\r\n              });\r\n\r\n              foundDataPoint = true;\r\n            }\r\n            break;\r\n\r\n          case \"line\":\r\n          case \"stepLine\":\r\n          case \"spline\":\r\n          case \"area\":\r\n          case \"stepArea\":\r\n          case \"stackedArea\":\r\n          case \"stackedArea100\":\r\n          case \"splineArea\":\r\n          case \"scatter\":\r\n            var markerSize = getProperty(\"markerSize\", dataPoint, this) || 4;\r\n            var snapDistance = getClosest ? 20 : markerSize;\r\n\r\n            distance = Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2));\r\n            if (distance <= snapDistance) {\r\n              results.push({\r\n                dataPoint: dataPoint,\r\n                dataPointIndex: i,\r\n                dataSeries: this,\r\n                distance: distance\r\n              });\r\n            }\r\n\r\n            var xDistance = Math.abs(visualInfo.x1 - x);\r\n            if (xDistance <= minimumXDistance)\r\n              minimumXDistance = xDistance;\r\n            else {\r\n              if (direction > 0)\r\n                forwardMissCount++;\r\n              else\r\n                backwardMissCount++;\r\n            }\r\n\r\n            if (distance <= markerSize / 2) {\r\n              foundDataPoint = true;\r\n            }\r\n\r\n            break;\r\n\r\n          case \"rangeArea\":\r\n          case \"rangeSplineArea\":\r\n\r\n            var markerSize = getProperty(\"markerSize\", dataPoint, this) || 4;\r\n            var snapDistance = getClosest ? 20 : markerSize;\r\n\r\n            distance = Math.min(Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2)), Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y2 - y, 2)));\r\n            if (distance <= snapDistance) {\r\n              results.push({\r\n                dataPoint: dataPoint,\r\n                dataPointIndex: i,\r\n                dataSeries: this,\r\n                distance: distance\r\n              });\r\n            }\r\n\r\n            var xDistance = Math.abs(visualInfo.x1 - x);\r\n            if (xDistance <= minimumXDistance)\r\n              minimumXDistance = xDistance;\r\n            else {\r\n              if (direction > 0)\r\n                forwardMissCount++;\r\n              else\r\n                backwardMissCount++;\r\n            }\r\n\r\n            if (distance <= markerSize / 2) {\r\n              foundDataPoint = true;\r\n            }\r\n\r\n            break;\r\n\r\n          case \"bubble\":\r\n            var markerSize = visualInfo.size;\r\n            distance = Math.sqrt(Math.pow(visualInfo.x1 - x, 2) + Math.pow(visualInfo.y1 - y, 2));\r\n            if (distance <= markerSize / 2) {\r\n              results.push({\r\n                dataPoint: dataPoint,\r\n                dataPointIndex: i,\r\n                dataSeries: this,\r\n                distance: distance\r\n              });\r\n\r\n              foundDataPoint = true;\r\n            }\r\n            break;\r\n\r\n          case \"pie\":\r\n          case \"doughnut\":\r\n            var center = visualInfo.center;\r\n            var innerRadius = this.type === \"doughnut\" ? visualInfo.percentInnerRadius * visualInfo.radius : 0;\r\n\r\n            distance = Math.sqrt(Math.pow(center.x - x, 2) + Math.pow(center.y - y, 2));\r\n            if (distance < visualInfo.radius && distance > innerRadius) {\r\n\r\n              var deltaY = y - center.y;\r\n              var deltaX = x - center.x;\r\n              var angle = Math.atan2(deltaY, deltaX);\r\n\r\n              if (angle < 0)\r\n                angle += Math.PI * 2;\r\n\r\n              angle = Number((((angle / Math.PI * 180 % 360) + 360) % 360).toFixed(12));\r\n              //console.log(angle);\r\n\r\n\r\n              var startAngle = Number((((visualInfo.startAngle / Math.PI * 180 % 360) + 360) % 360).toFixed(12));\r\n              var endAngle = Number((((visualInfo.endAngle / Math.PI * 180 % 360) + 360) % 360).toFixed(12));\r\n\r\n              //So that data point is detected when there is only one dataPoint\r\n              if (endAngle === 0 && visualInfo.endAngle > 1) {\r\n                endAngle = 360;\r\n              }\r\n\r\n              if (startAngle >= endAngle && dataPoint.y !== 0) {\r\n                endAngle += 360;\r\n\r\n                if (angle < startAngle)\r\n                  angle += 360;\r\n              }\r\n\r\n\r\n              if (angle > startAngle && angle < endAngle) {\r\n                results.push({\r\n                  dataPoint: dataPoint,\r\n                  dataPointIndex: i,\r\n                  dataSeries: this,\r\n                  distance: 0\r\n                });\r\n\r\n                foundDataPoint = true;\r\n              }\r\n\r\n            }\r\n\r\n            break;\r\n\r\n          case \"candlestick\":\r\n            if (((x >= (visualInfo.x1 - visualInfo.borderThickness / 2)) && (x <= (visualInfo.x2 + visualInfo.borderThickness / 2))\r\n              && (y >= visualInfo.y2 - visualInfo.borderThickness / 2) && (y <= visualInfo.y3 + visualInfo.borderThickness / 2))\r\n              || (Math.abs(visualInfo.x2 - x + visualInfo.x1 - x) < visualInfo.borderThickness && (y >= visualInfo.y1 && y <= visualInfo.y4))) {\r\n              results.push({\r\n                dataPoint: dataPoint,\r\n                dataPointIndex: i,\r\n                dataSeries: this,\r\n                distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y2 - y), Math.abs(visualInfo.y3 - y))\r\n                //distance:0\r\n              });\r\n\r\n              foundDataPoint = true;\r\n            }\r\n            break;\r\n\r\n          case \"ohlc\":\r\n\r\n            if ((Math.abs(visualInfo.x2 - x + visualInfo.x1 - x) < visualInfo.borderThickness && (y >= visualInfo.y2 && y <= visualInfo.y3))\r\n\r\n              || (x >= visualInfo.x1 && (x <= (visualInfo.x2 + visualInfo.x1) / 2)\r\n                && (y >= visualInfo.y1 - visualInfo.borderThickness / 2) && (y <= visualInfo.y1 + visualInfo.borderThickness / 2))\r\n\r\n              || ((x >= (visualInfo.x1 + visualInfo.x2) / 2) && (x <= visualInfo.x2)\r\n                && (y >= visualInfo.y4 - visualInfo.borderThickness / 2) && (y <= visualInfo.y4 + visualInfo.borderThickness / 2))) {\r\n\r\n              results.push({\r\n                dataPoint: dataPoint,\r\n                dataPointIndex: i,\r\n                dataSeries: this,\r\n                distance: Math.min(Math.abs(visualInfo.x1 - x), Math.abs(visualInfo.x2 - x), Math.abs(visualInfo.y2 - y), Math.abs(visualInfo.y3 - y))\r\n                //distance:0\r\n              });\r\n\r\n              foundDataPoint = true;\r\n            }\r\n            break;\r\n\r\n        }\r\n\r\n        if (foundDataPoint || (forwardMissCount > maxMissCount && backwardMissCount > maxMissCount))\r\n          break;\r\n      }\r\n\r\n    } else if (searchStartIndex - j < 0 && searchStartIndex + j >= this.dataPoints.length)\r\n      break;\r\n\r\n    if (direction === -1) {\r\n      j++;\r\n      direction = 1;\r\n    } else\r\n      direction = -1;\r\n\r\n  }\r\n\r\n\r\n\r\n  var closestResult = null;\r\n\r\n  for (var m = 0; m < results.length; m++) {\r\n    if (!closestResult) {\r\n      closestResult = results[m];\r\n    } else if (results[m].distance <= closestResult.distance) {\r\n      closestResult = results[m];\r\n    }\r\n  }\r\n\r\n  //if (window.console)\r\n  //\twindow.console.log(\"forwardMissCount: \" + forwardMissCount + \"; backwardMissCount: \" + backwardMissCount + \"; getClosest: \" + getClosest);\r\n\r\n  //if (window.console && closestResult)\r\n  //    window.console.log(j + \": distance = \" + closestResult.distance);\r\n\r\n  return closestResult;\r\n}\r\n\r\nDataSeries.prototype.getMarkerProperties = function (index, x, y, ctx) {\r\n  var dataPoints = this.dataPoints;\r\n  var dataSeries = this;\r\n\r\n  var markerColor = dataPoints[index].markerColor ? dataPoints[index].markerColor : dataSeries.markerColor ? dataSeries.markerColor : dataPoints[index].color ? dataPoints[index].color : dataSeries.color ? dataSeries.color : dataSeries._colorSet[index % dataSeries._colorSet.length];\r\n  var markerBorderColor = dataPoints[index].markerBorderColor ? dataPoints[index].markerBorderColor : dataSeries.markerBorderColor ? dataSeries.markerBorderColor : null;\r\n  var markerBorderThickness = dataPoints[index].markerBorderThickness ? dataPoints[index].markerBorderThickness : dataSeries.markerBorderThickness ? dataSeries.markerBorderThickness : null;\r\n  var markerType = dataPoints[index].markerType ? dataPoints[index].markerType : dataSeries.markerType;\r\n  var markerSize = dataPoints[index].markerSize ? dataPoints[index].markerSize : dataSeries.markerSize;\r\n\r\n\r\n  return {\r\n    x: x, y: y, ctx: ctx,\r\n    type: markerType,\r\n    size: markerSize,\r\n    color: markerColor,\r\n    borderColor: markerBorderColor,\r\n    borderThickness: markerBorderThickness\r\n  }\r\n}\r\n\r\nexport default DataSeries;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}