{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport DataSeries from './data_series';\nimport CanvasJSObject from './canvasjs';\nimport TextBlock from './text_block';\nimport RenderHelper from '../helpers/render';\nimport { extend, getFontHeightInPixels } from '../helpers/utils';\nfunction Legend(chart, options, theme) {\n  Legend.base.constructor.call(this, \"Legend\", options, theme);\n  this.chart = chart;\n  this.canvas = chart.canvas;\n  this.ctx = this.chart.ctx;\n  this.ghostCtx = this.chart._eventManager.ghostCtx;\n  this.items = [];\n  this.width = 0,\n  //this.fontSize = 12,\n  this.height = 0, this.orientation = null, this.dataSeries = [];\n  this.bounds = {\n    x1: null,\n    y1: null,\n    x2: null,\n    y2: null\n  };\n  if (typeof this._options.fontSize === \"undefined\") {\n    this.fontSize = this.chart.getAutoFontSize(this.fontSize);\n    //window.console.log(\"fontSize: \" + this.fontSize);\n  }\n  this.lineHeight = getFontHeightInPixels(this.fontFamily, this.fontSize, this.fontWeight);\n  this.horizontalSpacing = this.fontSize;\n}\nextend(Legend, CanvasJSObject);\nLegend.prototype.render = function () {\n  var container = !this.dockInsidePlotArea ? this.chart : this.chart.plotArea;\n  var freeSpace = container.layoutManager.getFreeSpace();\n  var position = null;\n  var top = 0;\n  var left = 0;\n  var maxWidth = 0;\n  var maxHeight = 0;\n  var itemMargin = 5;\n  var items = [];\n  var rows = [];\n\n  //this.ctx.font = getFontString(\"\", this, null);\n  //this.ctx.fontColor = this.fontColor;\n\n  if (this.verticalAlign === \"top\" || this.verticalAlign === \"bottom\") {\n    this.orientation = \"horizontal\";\n    position = this.verticalAlign;\n    maxWidth = this.maxWidth !== null ? this.maxWidth : freeSpace.width * .7;\n    maxHeight = this.maxHeight !== null ? this.maxHeight : freeSpace.height * .5;\n  } else if (this.verticalAlign === \"center\") {\n    this.orientation = \"vertical\";\n    position = this.horizontalAlign;\n    maxWidth = this.maxWidth !== null ? this.maxWidth : freeSpace.width * .5;\n    maxHeight = this.maxHeight !== null ? this.maxHeight : freeSpace.height * .7;\n  }\n  for (var i = 0; i < this.dataSeries.length; i++) {\n    var dataSeries = this.dataSeries[i];\n    if (dataSeries.type !== \"pie\" && dataSeries.type !== \"doughnut\" && dataSeries.type !== \"funnel\") {\n      var markerType = dataSeries.legendMarkerType ? dataSeries.legendMarkerType : (dataSeries.type === \"line\" || dataSeries.type === \"stepLine\" || dataSeries.type === \"spline\" || dataSeries.type === \"scatter\" || dataSeries.type === \"bubble\") && dataSeries.markerType ? dataSeries.markerType : DataSeries.getDefaultLegendMarker(dataSeries.type);\n      var legendText = dataSeries.legendText ? dataSeries.legendText : this.itemTextFormatter ? this.itemTextFormatter({\n        chart: this.chart,\n        legend: this._options,\n        dataSeries: dataSeries,\n        dataPoint: null\n      }) : dataSeries.name;\n      var markerColor = dataSeries.legendMarkerColor ? dataSeries.legendMarkerColor : dataSeries.markerColor ? dataSeries.markerColor : dataSeries._colorSet[0];\n      var markerSize = !dataSeries.markerSize && (dataSeries.type === \"line\" || dataSeries.type === \"stepLine\" || dataSeries.type === \"spline\") ? 0 : this.lineHeight * .6;\n      var markerBorderColor = dataSeries.legendMarkerBorderColor ? dataSeries.legendMarkerBorderColor : dataSeries.markerBorderColor;\n      var markerBorderThickness = dataSeries.legendMarkerBorderThickness ? dataSeries.legendMarkerBorderThickness : dataSeries.markerBorderThickness ? Math.max(1, Math.round(markerSize * .2)) : 0;\n      var lineColor = dataSeries._colorSet[0];\n      legendText = this.chart.replaceKeywordsWithValue(legendText, dataSeries.dataPoints[0], dataSeries, i);\n      var item = {\n        markerType: markerType,\n        markerColor: markerColor,\n        text: legendText,\n        textBlock: null,\n        chartType: dataSeries.type,\n        markerSize: markerSize,\n        lineColor: dataSeries._colorSet[0],\n        dataSeriesIndex: dataSeries.index,\n        dataPointIndex: null,\n        markerBorderColor: markerBorderColor,\n        markerBorderThickness: markerBorderThickness\n      };\n      items.push(item);\n    } else {\n      for (var dataPointIndex = 0; dataPointIndex < dataSeries.dataPoints.length; dataPointIndex++) {\n        var dataPoint = dataSeries.dataPoints[dataPointIndex];\n        var markerType = dataPoint.legendMarkerType ? dataPoint.legendMarkerType : dataSeries.legendMarkerType ? dataSeries.legendMarkerType : DataSeries.getDefaultLegendMarker(dataSeries.type);\n        var legendText = dataPoint.legendText ? dataPoint.legendText : dataSeries.legendText ? dataSeries.legendText : this.itemTextFormatter ? this.itemTextFormatter({\n          chart: this.chart,\n          legend: this._options,\n          dataSeries: dataSeries,\n          dataPoint: dataPoint\n        }) : dataPoint.name ? dataPoint.name : \"DataPoint: \" + (dataPointIndex + 1);\n        var markerColor = dataPoint.legendMarkerColor ? dataPoint.legendMarkerColor : dataSeries.legendMarkerColor ? dataSeries.legendMarkerColor : dataPoint.color ? dataPoint.color : dataSeries.color ? dataSeries.color : dataSeries._colorSet[dataPointIndex % dataSeries._colorSet.length];\n        var markerSize = this.lineHeight * .6;\n        var markerBorderColor = dataPoint.legendMarkerBorderColor ? dataPoint.legendMarkerBorderColor : dataSeries.legendMarkerBorderColor ? dataSeries.legendMarkerBorderColor : dataPoint.markerBorderColor ? dataPoint.markerBorderColor : dataSeries.markerBorderColor;\n        var markerBorderThickness = dataPoint.legendMarkerBorderThickness ? dataPoint.legendMarkerBorderThickness : dataSeries.legendMarkerBorderThickness ? dataSeries.legendMarkerBorderThickness : dataPoint.markerBorderThickness || dataSeries.markerBorderThickness ? Math.max(1, Math.round(markerSize * .2)) : 0;\n        legendText = this.chart.replaceKeywordsWithValue(legendText, dataPoint, dataSeries, dataPointIndex);\n        var item = {\n          markerType: markerType,\n          markerColor: markerColor,\n          text: legendText,\n          textBlock: null,\n          chartType: dataSeries.type,\n          markerSize: markerSize,\n          dataSeriesIndex: i,\n          dataPointIndex: dataPointIndex,\n          markerBorderColor: markerBorderColor,\n          markerBorderThickness: markerBorderThickness\n        };\n        if (dataPoint.showInLegend || dataSeries.showInLegend && dataPoint.showInLegend !== false) {\n          items.push(item);\n        }\n      }\n    }\n    item = null;\n  }\n  if (this.reversed === true) {\n    items.reverse();\n  }\n\n  // Find out the required width and height of Legend and position the items relative to the container\n  if (items.length > 0) {\n    var row = null;\n    var rowIndex = 0; // required for vertical orientation\n    var textMaxWidth = 0;\n    var columnHeight = 0;\n    if (this.itemWidth !== null) {\n      if (this.itemMaxWidth !== null) {\n        textMaxWidth = Math.min(this.itemWidth, this.itemMaxWidth, maxWidth);\n      } else {\n        textMaxWidth = Math.min(this.itemWidth, maxWidth);\n      }\n    } else {\n      if (this.itemMaxWidth !== null) {\n        textMaxWidth = Math.min(this.itemMaxWidth, maxWidth);\n      } else {\n        textMaxWidth = maxWidth;\n      }\n    }\n    markerSize = markerSize === 0 ? this.lineHeight * .6 : markerSize;\n    textMaxWidth = textMaxWidth - (markerSize + this.horizontalSpacing * .1);\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n      if (item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\") {\n        textMaxWidth = textMaxWidth - 2 * (this.lineHeight * .1);\n      }\n      if (maxHeight <= 0 || typeof maxHeight === \"undefined\" || textMaxWidth <= 0 || typeof textMaxWidth === \"undefined\") {\n        continue;\n      }\n      if (this.orientation === \"horizontal\") {\n        item.textBlock = new TextBlock(this.ctx, {\n          x: 0,\n          y: 0,\n          //TBI\n          maxWidth: textMaxWidth,\n          maxHeight: this.itemWrap ? maxHeight : this.lineHeight,\n          //TBI: FontSize\n          angle: 0,\n          text: item.text,\n          horizontalAlign: \"left\",\n          //left, center, right\n          fontSize: this.fontSize,\n          //in pixels\n          fontFamily: this.fontFamily,\n          fontWeight: this.fontWeight,\n          //normal, bold, bolder, lighter,\n          fontColor: this.fontColor,\n          fontStyle: this.fontStyle,\n          // normal, italic, oblique\n          textBaseline: \"top\"\n        });\n        item.textBlock.measureText();\n        if (this.itemWidth !== null) {\n          item.textBlock.width = this.itemWidth - (markerSize + this.horizontalSpacing * .1 + (item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\" ? 2 * (this.lineHeight * .1) : 0));\n        }\n        if (!row || row.width + Math.round(item.textBlock.width + this.horizontalSpacing * .1 + markerSize + (row.width === 0 ? 0 : this.horizontalSpacing) + (item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\" ? 2 * (this.lineHeight * .1) : 0)) > maxWidth) {\n          row = {\n            items: [],\n            width: 0\n          };\n          rows.push(row);\n          this.height += columnHeight;\n          columnHeight = 0;\n        }\n        columnHeight = Math.max(columnHeight, item.textBlock.height);\n        item.textBlock.x = row.width;\n        item.textBlock.y = 0;\n        row.width += Math.round(item.textBlock.width + this.horizontalSpacing * .1 + markerSize + (row.width === 0 ? 0 : this.horizontalSpacing) + (item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\" ? 2 * (this.lineHeight * .1) : 0));\n        row.items.push(item);\n        this.width = Math.max(row.width, this.width);\n      } else {\n        item.textBlock = new TextBlock(this.ctx, {\n          x: 0,\n          y: 0,\n          //TBI\n          maxWidth: textMaxWidth,\n          maxHeight: this.itemWrap === true ? maxHeight : this.fontSize * 1.5,\n          //TBI: FontSize\n          angle: 0,\n          text: item.text,\n          horizontalAlign: \"left\",\n          //left, center, right\n          fontSize: this.fontSize,\n          //in pixels\n          fontFamily: this.fontFamily,\n          fontWeight: this.fontWeight,\n          //normal, bold, bolder, lighter,\n          fontColor: this.fontColor,\n          fontStyle: this.fontStyle,\n          // normal, italic, oblique\n          textBaseline: \"top\"\n        });\n        item.textBlock.measureText();\n        if (this.itemWidth !== null) {\n          item.textBlock.width = this.itemWidth - (markerSize + this.horizontalSpacing * .1 + (item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\" ? 2 * (this.lineHeight * .1) : 0));\n        }\n        if (this.height <= maxHeight) {\n          row = {\n            items: [],\n            width: 0\n          };\n          rows.push(row);\n        } else {\n          row = rows[rowIndex];\n          rowIndex = (rowIndex + 1) % rows.length;\n        }\n        this.height += item.textBlock.height;\n        item.textBlock.x = row.width; // relative to the row\n        item.textBlock.y = 0; // relative to the row\n\n        row.width += Math.round(item.textBlock.width + this.horizontalSpacing * .1 + markerSize + (row.width === 0 ? 0 : this.horizontalSpacing) + (item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\" ? 2 * (this.lineHeight * .1) : 0));\n        row.items.push(item);\n        this.width = Math.max(row.width, this.width);\n      }\n    }\n    if (this.itemWrap === false) {\n      this.height = rows.length * this.lineHeight;\n    } else {\n      this.height += columnHeight;\n    }\n    this.height = Math.min(maxHeight, this.height);\n    this.width = Math.min(maxWidth, this.width);\n  }\n  if (this.verticalAlign === \"top\") {\n    if (this.horizontalAlign === \"left\") left = freeSpace.x1;else if (this.horizontalAlign === \"right\") left = freeSpace.x2 - this.width;else left = freeSpace.x1 + freeSpace.width / 2 - this.width / 2;\n    top = freeSpace.y1;\n  } else if (this.verticalAlign === \"center\") {\n    if (this.horizontalAlign === \"left\") left = freeSpace.x1;else if (this.horizontalAlign === \"right\") left = freeSpace.x2 - this.width;else left = freeSpace.x1 + freeSpace.width / 2 - this.width / 2;\n    top = freeSpace.y1 + freeSpace.height / 2 - this.height / 2;\n  } else if (this.verticalAlign === \"bottom\") {\n    if (this.horizontalAlign === \"left\") left = freeSpace.x1;else if (this.horizontalAlign === \"right\") left = freeSpace.x2 - this.width;else left = freeSpace.x1 + freeSpace.width / 2 - this.width / 2;\n    top = freeSpace.y2 - this.height;\n  }\n  this.items = items;\n\n  //Assign ids to all legendItems\n  for (var i = 0; i < this.items.length; i++) {\n    var item = items[i];\n    item.id = ++this.chart._eventManager.lastObjectId;\n    this.chart._eventManager.objectMap[item.id] = {\n      id: item.id,\n      objectType: \"legendItem\",\n      legendItemIndex: i,\n      dataSeriesIndex: item.dataSeriesIndex,\n      dataPointIndex: item.dataPointIndex\n    };\n    //delete item.textBlock;// Not Required anymore\n  }\n  var rowHeight = 0;\n  for (var i = 0; i < rows.length; i++) {\n    var row = rows[i];\n    var columnHeight = 0;\n    for (var itemIndex = 0; itemIndex < row.items.length; itemIndex++) {\n      var item = row.items[itemIndex];\n      var itemX = item.textBlock.x + left + (itemIndex === 0 ? markerSize * .2 : this.horizontalSpacing);\n      var itemY = top + rowHeight;\n      var ghostX = itemX;\n      if (!this.chart.data[item.dataSeriesIndex].visible) this.ctx.globalAlpha = .5;\n      this.ctx.save();\n      this.ctx.rect(left, top, maxWidth, maxHeight);\n      this.ctx.clip();\n      if (item.chartType === \"line\" || item.chartType === \"stepLine\" || item.chartType === \"spline\") {\n        this.ctx.strokeStyle = item.lineColor;\n        this.ctx.lineWidth = Math.ceil(this.lineHeight / 8);\n        this.ctx.beginPath();\n        this.ctx.moveTo(itemX - this.lineHeight * .1, itemY + this.lineHeight / 2);\n        this.ctx.lineTo(itemX + this.lineHeight * .7, itemY + this.lineHeight / 2);\n        this.ctx.stroke();\n        ghostX -= this.lineHeight * .1;\n      }\n      RenderHelper.drawMarker(itemX + markerSize / 2, itemY + this.lineHeight / 2, this.ctx, item.markerType, item.markerSize, item.markerColor, item.markerBorderColor, item.markerBorderThickness);\n      item.textBlock.x = itemX + this.horizontalSpacing * .1 + markerSize;\n      if (item.chartType === \"line\" || item.chartType === \"stepLine\" || item.chartType === \"spline\") {\n        item.textBlock.x = item.textBlock.x + this.lineHeight * .1;\n      }\n      item.textBlock.y = itemY;\n      item.textBlock.render(true);\n      this.ctx.restore();\n      if (itemIndex > 0) {\n        columnHeight = Math.max(columnHeight, item.textBlock.height);\n      } else {\n        columnHeight = item.textBlock.height;\n      }\n      if (!this.chart.data[item.dataSeriesIndex].visible) this.ctx.globalAlpha = 1;\n      var hexColor = intToHexColorString(item.id);\n      this.ghostCtx.fillStyle = hexColor;\n      this.ghostCtx.beginPath();\n      this.ghostCtx.fillRect(ghostX, item.textBlock.y, item.textBlock.x + item.textBlock.width - ghostX, item.textBlock.height);\n      item.x1 = this.chart._eventManager.objectMap[item.id].x1 = ghostX;\n      item.y1 = this.chart._eventManager.objectMap[item.id].y1 = item.textBlock.y;\n      item.x2 = this.chart._eventManager.objectMap[item.id].x2 = item.textBlock.x + item.textBlock.width;\n      item.y2 = this.chart._eventManager.objectMap[item.id].y2 = item.textBlock.y + item.textBlock.height;\n    }\n    rowHeight = rowHeight + columnHeight;\n  }\n\n  //this.ctx.beginPath();\n  //this.ctx.lineWidth = 2;\n  //this.ctx.strokeStyle = \"red\";\n  //this.ctx.rect(left, top, this.width, this.height);\n  //this.ctx.stroke();\n\n  container.layoutManager.registerSpace(position, {\n    width: this.width + 2 + 2,\n    height: this.height + 5 + 5\n  });\n  this.bounds = {\n    x1: left,\n    y1: top,\n    x2: left + this.width,\n    y2: top + this.height\n  };\n};\nexport default Legend;","map":{"version":3,"names":["DataSeries","CanvasJSObject","TextBlock","RenderHelper","extend","getFontHeightInPixels","Legend","chart","options","theme","base","constructor","call","canvas","ctx","ghostCtx","_eventManager","items","width","height","orientation","dataSeries","bounds","x1","y1","x2","y2","_options","fontSize","getAutoFontSize","lineHeight","fontFamily","fontWeight","horizontalSpacing","prototype","render","container","dockInsidePlotArea","plotArea","freeSpace","layoutManager","getFreeSpace","position","top","left","maxWidth","maxHeight","itemMargin","rows","verticalAlign","horizontalAlign","i","length","type","markerType","legendMarkerType","getDefaultLegendMarker","legendText","itemTextFormatter","legend","dataPoint","name","markerColor","legendMarkerColor","_colorSet","markerSize","markerBorderColor","legendMarkerBorderColor","markerBorderThickness","legendMarkerBorderThickness","Math","max","round","lineColor","replaceKeywordsWithValue","dataPoints","item","text","textBlock","chartType","dataSeriesIndex","index","dataPointIndex","push","color","showInLegend","reversed","reverse","row","rowIndex","textMaxWidth","columnHeight","itemWidth","itemMaxWidth","min","x","y","itemWrap","angle","fontColor","fontStyle","textBaseline","measureText","id","lastObjectId","objectMap","objectType","legendItemIndex","rowHeight","itemIndex","itemX","itemY","ghostX","data","visible","globalAlpha","save","rect","clip","strokeStyle","lineWidth","ceil","beginPath","moveTo","lineTo","stroke","drawMarker","restore","hexColor","intToHexColorString","fillStyle","fillRect","registerSpace"],"sources":["C:/Users/IMPEGNOABS010/Desktop/HRMSROUT/node_modules/canvasjs/src/core/legend.js"],"sourcesContent":["\r\nimport DataSeries from './data_series';\r\nimport CanvasJSObject from './canvasjs';\r\nimport TextBlock from './text_block';\r\nimport RenderHelper from '../helpers/render';\r\nimport {extend, getFontHeightInPixels} from '../helpers/utils';\r\n\r\nfunction Legend(chart, options, theme) {\r\n  Legend.base.constructor.call(this, \"Legend\", options, theme);\r\n\r\n  this.chart = chart;\r\n  this.canvas = chart.canvas;\r\n  this.ctx = this.chart.ctx;\r\n  this.ghostCtx = this.chart._eventManager.ghostCtx;\r\n  this.items = [];\r\n\r\n  this.width = 0,\r\n  //this.fontSize = 12,\r\n  this.height = 0,\r\n  this.orientation = null,\r\n  this.dataSeries = [];\r\n  this.bounds = {\r\n    x1: null, y1: null, x2: null, y2: null\r\n  };\r\n\r\n  if (typeof (this._options.fontSize) === \"undefined\") {\r\n    this.fontSize = this.chart.getAutoFontSize(this.fontSize);\r\n    //window.console.log(\"fontSize: \" + this.fontSize);\r\n  }\r\n\r\n  this.lineHeight = getFontHeightInPixels(this.fontFamily, this.fontSize, this.fontWeight);\r\n\r\n  this.horizontalSpacing = this.fontSize;\r\n}\r\n\r\nextend(Legend, CanvasJSObject);\r\n\r\nLegend.prototype.render = function () {\r\n\r\n  var container = (!this.dockInsidePlotArea ? this.chart : this.chart.plotArea);\r\n  var freeSpace = container.layoutManager.getFreeSpace();\r\n  var position = null;\r\n  var top = 0;\r\n  var left = 0;\r\n  var maxWidth = 0;\r\n  var maxHeight = 0;\r\n  var itemMargin = 5;\r\n\r\n  var items = [];\r\n  var rows = [];\r\n\r\n  //this.ctx.font = getFontString(\"\", this, null);\r\n  //this.ctx.fontColor = this.fontColor;\r\n\r\n  if (this.verticalAlign === \"top\" || this.verticalAlign === \"bottom\") {\r\n    this.orientation = \"horizontal\";\r\n    position = this.verticalAlign;\r\n\r\n    maxWidth = this.maxWidth !== null ? this.maxWidth : freeSpace.width * .7;\r\n    maxHeight = this.maxHeight !== null ? this.maxHeight : freeSpace.height * .5;\r\n  }\r\n  else if (this.verticalAlign === \"center\") {\r\n    this.orientation = \"vertical\";\r\n    position = this.horizontalAlign;\r\n\r\n    maxWidth = this.maxWidth !== null ? this.maxWidth : freeSpace.width * .5;\r\n    maxHeight = this.maxHeight !== null ? this.maxHeight : freeSpace.height * .7;\r\n  }\r\n\r\n  for (var i = 0; i < this.dataSeries.length; i++) {\r\n    var dataSeries = this.dataSeries[i];\r\n\r\n\r\n    if (dataSeries.type !== \"pie\" && dataSeries.type !== \"doughnut\" && dataSeries.type !== \"funnel\") {\r\n\r\n      var markerType = dataSeries.legendMarkerType ? dataSeries.legendMarkerType : (dataSeries.type === \"line\" || dataSeries.type === \"stepLine\" || dataSeries.type === \"spline\" || dataSeries.type === \"scatter\" || dataSeries.type === \"bubble\") && dataSeries.markerType ? dataSeries.markerType : DataSeries.getDefaultLegendMarker(dataSeries.type);\r\n      var legendText = dataSeries.legendText ? dataSeries.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this._options, dataSeries: dataSeries, dataPoint: null })\r\n        : dataSeries.name;\r\n      var markerColor = dataSeries.legendMarkerColor ? dataSeries.legendMarkerColor : dataSeries.markerColor ? dataSeries.markerColor : dataSeries._colorSet[0];\r\n      var markerSize = (!dataSeries.markerSize && (dataSeries.type === \"line\" || dataSeries.type === \"stepLine\" || dataSeries.type === \"spline\")) ? 0 : this.lineHeight * .6;\r\n      var markerBorderColor = dataSeries.legendMarkerBorderColor ? dataSeries.legendMarkerBorderColor : dataSeries.markerBorderColor;\r\n      var markerBorderThickness = dataSeries.legendMarkerBorderThickness ? dataSeries.legendMarkerBorderThickness : dataSeries.markerBorderThickness ? Math.max(1, Math.round(markerSize * .2)) : 0;\r\n      var lineColor = dataSeries._colorSet[0];\r\n\r\n      legendText = this.chart.replaceKeywordsWithValue(legendText, dataSeries.dataPoints[0], dataSeries, i);\r\n      var item = {\r\n        markerType: markerType, markerColor: markerColor, text: legendText, textBlock: null, chartType: dataSeries.type, markerSize: markerSize, lineColor: dataSeries._colorSet[0],\r\n        dataSeriesIndex: dataSeries.index, dataPointIndex: null, markerBorderColor: markerBorderColor, markerBorderThickness: markerBorderThickness\r\n      };\r\n\r\n      items.push(item);\r\n    } else {\r\n      for (var dataPointIndex = 0; dataPointIndex < dataSeries.dataPoints.length; dataPointIndex++) {\r\n\r\n        var dataPoint = dataSeries.dataPoints[dataPointIndex];\r\n\r\n        var markerType = dataPoint.legendMarkerType ? dataPoint.legendMarkerType : dataSeries.legendMarkerType ? dataSeries.legendMarkerType : DataSeries.getDefaultLegendMarker(dataSeries.type);\r\n        var legendText = dataPoint.legendText ? dataPoint.legendText : dataSeries.legendText ? dataSeries.legendText : this.itemTextFormatter ? this.itemTextFormatter({ chart: this.chart, legend: this._options, dataSeries: dataSeries, dataPoint: dataPoint })\r\n          : dataPoint.name ? dataPoint.name : \"DataPoint: \" + (dataPointIndex + 1);\r\n        var markerColor = dataPoint.legendMarkerColor ? dataPoint.legendMarkerColor : dataSeries.legendMarkerColor ? dataSeries.legendMarkerColor : dataPoint.color ? dataPoint.color : dataSeries.color ? dataSeries.color : dataSeries._colorSet[dataPointIndex % dataSeries._colorSet.length];\r\n        var markerSize = this.lineHeight * .6;\r\n        var markerBorderColor = dataPoint.legendMarkerBorderColor ? dataPoint.legendMarkerBorderColor : dataSeries.legendMarkerBorderColor ? dataSeries.legendMarkerBorderColor : dataPoint.markerBorderColor ? dataPoint.markerBorderColor : dataSeries.markerBorderColor;\r\n        var markerBorderThickness = dataPoint.legendMarkerBorderThickness ? dataPoint.legendMarkerBorderThickness : dataSeries.legendMarkerBorderThickness ? dataSeries.legendMarkerBorderThickness : dataPoint.markerBorderThickness || dataSeries.markerBorderThickness ? Math.max(1, Math.round(markerSize * .2)) : 0;\r\n\r\n        legendText = this.chart.replaceKeywordsWithValue(legendText, dataPoint, dataSeries, dataPointIndex);\r\n\r\n        var item = {\r\n          markerType: markerType, markerColor: markerColor, text: legendText, textBlock: null, chartType: dataSeries.type, markerSize: markerSize,\r\n          dataSeriesIndex: i, dataPointIndex: dataPointIndex, markerBorderColor: markerBorderColor, markerBorderThickness: markerBorderThickness\r\n        };\r\n\r\n        if (dataPoint.showInLegend || (dataSeries.showInLegend && dataPoint.showInLegend !== false)) {\r\n          items.push(item);\r\n        }\r\n      }\r\n    }\r\n    item = null;\r\n  }\r\n  if (this.reversed === true) {\r\n    items.reverse();\r\n  }\r\n\r\n  // Find out the required width and height of Legend and position the items relative to the container\r\n  if (items.length > 0) {\r\n    var row = null;\r\n    var rowIndex = 0; // required for vertical orientation\r\n    var textMaxWidth = 0;\r\n    var columnHeight = 0;\r\n\r\n    if (this.itemWidth !== null) {\r\n      if (this.itemMaxWidth !== null) {\r\n        textMaxWidth = Math.min(this.itemWidth, this.itemMaxWidth, maxWidth);\r\n      } else {\r\n        textMaxWidth = Math.min(this.itemWidth, maxWidth);\r\n      }\r\n    } else {\r\n      if (this.itemMaxWidth !== null) {\r\n        textMaxWidth = Math.min(this.itemMaxWidth, maxWidth);\r\n      } else {\r\n        textMaxWidth = maxWidth;\r\n      }\r\n    }\r\n\r\n    markerSize = (markerSize === 0 ? this.lineHeight * .6 : markerSize);\r\n    textMaxWidth = textMaxWidth - (markerSize + this.horizontalSpacing * .1);\r\n\r\n    for (var i = 0; i < items.length; i++) {\r\n      var item = items[i];\r\n\r\n      if (item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\") {\r\n        textMaxWidth = textMaxWidth - 2 * (this.lineHeight * .1);\r\n      }\r\n\r\n      if (maxHeight <= 0 || typeof (maxHeight) === \"undefined\" || textMaxWidth <= 0 || typeof (textMaxWidth) === \"undefined\") {\r\n        continue;\r\n      }\r\n\r\n      if (this.orientation === \"horizontal\") {\r\n\r\n        item.textBlock = new TextBlock(this.ctx, {\r\n          x: 0,\r\n          y: 0,//TBI\r\n          maxWidth: textMaxWidth,\r\n          maxHeight: this.itemWrap ? maxHeight : this.lineHeight, //TBI: FontSize\r\n          angle: 0,\r\n          text: item.text,\r\n          horizontalAlign: \"left\",//left, center, right\r\n          fontSize: this.fontSize,//in pixels\r\n          fontFamily: this.fontFamily,\r\n          fontWeight: this.fontWeight, //normal, bold, bolder, lighter,\r\n          fontColor: this.fontColor,\r\n          fontStyle: this.fontStyle, // normal, italic, oblique\r\n          textBaseline: \"top\"\r\n        });\r\n        item.textBlock.measureText();\r\n\r\n        if (this.itemWidth !== null) {\r\n          item.textBlock.width = this.itemWidth - (markerSize + this.horizontalSpacing * .1 + ((item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\") ? 2 * (this.lineHeight * .1) : 0));\r\n        }\r\n\r\n        if (!row || row.width + Math.round(item.textBlock.width + this.horizontalSpacing * .1 + markerSize + (row.width === 0 ? 0 : (this.horizontalSpacing)) + ((item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\") ? 2 * (this.lineHeight * .1) : 0)) > maxWidth) {\r\n          row = {\r\n            items: [], width: 0\r\n          };\r\n          rows.push(row);\r\n          this.height += columnHeight;\r\n          columnHeight = 0;\r\n        }\r\n\r\n        columnHeight = Math.max(columnHeight, item.textBlock.height);\r\n\r\n        item.textBlock.x = row.width;\r\n        item.textBlock.y = 0;\r\n\r\n        row.width += Math.round(item.textBlock.width + this.horizontalSpacing * .1 + markerSize + (row.width === 0 ? 0 : this.horizontalSpacing) + ((item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\") ? 2 * (this.lineHeight * .1) : 0));\r\n        row.items.push(item);\r\n\r\n        this.width = Math.max(row.width, this.width);\r\n      } else {\r\n\r\n        item.textBlock = new TextBlock(this.ctx, {\r\n          x: 0,\r\n          y: 0,//TBI\r\n          maxWidth: textMaxWidth,\r\n          maxHeight: this.itemWrap === true ? maxHeight : this.fontSize * 1.5, //TBI: FontSize\r\n          angle: 0,\r\n          text: item.text,\r\n          horizontalAlign: \"left\",//left, center, right\r\n          fontSize: this.fontSize,//in pixels\r\n          fontFamily: this.fontFamily,\r\n          fontWeight: this.fontWeight, //normal, bold, bolder, lighter,\r\n          fontColor: this.fontColor,\r\n          fontStyle: this.fontStyle, // normal, italic, oblique\r\n          textBaseline: \"top\"\r\n        });\r\n\r\n        item.textBlock.measureText();\r\n\r\n        if (this.itemWidth !== null) {\r\n          item.textBlock.width = this.itemWidth - (markerSize + this.horizontalSpacing * .1 + ((item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\") ? 2 * (this.lineHeight * .1) : 0));\r\n        }\r\n\r\n        if (this.height <= maxHeight) {\r\n          row = {\r\n            items: [], width: 0\r\n          };\r\n          rows.push(row);\r\n        } else {\r\n          row = rows[rowIndex];\r\n          rowIndex = (rowIndex + 1) % rows.length;\r\n        }\r\n\r\n        this.height += item.textBlock.height;\r\n\r\n        item.textBlock.x = row.width; // relative to the row\r\n        item.textBlock.y = 0; // relative to the row\r\n\r\n        row.width += Math.round(item.textBlock.width + this.horizontalSpacing * .1 + markerSize + (row.width === 0 ? 0 : this.horizontalSpacing) + ((item.chartType === \"line\" || item.chartType === \"spline\" || item.chartType === \"stepLine\") ? 2 * (this.lineHeight * .1) : 0));\r\n        row.items.push(item);\r\n\r\n        this.width = Math.max(row.width, this.width);\r\n      }\r\n    }\r\n\r\n    if (this.itemWrap === false) {\r\n      this.height = rows.length * (this.lineHeight);\r\n    } else {\r\n      this.height += columnHeight;\r\n    }\r\n\r\n    this.height = Math.min(maxHeight, this.height);\r\n    this.width = Math.min(maxWidth, this.width);\r\n  }\r\n\r\n  if (this.verticalAlign === \"top\") {\r\n    if (this.horizontalAlign === \"left\")\r\n      left = freeSpace.x1;\r\n    else if (this.horizontalAlign === \"right\")\r\n      left = freeSpace.x2 - this.width;\r\n    else\r\n      left = freeSpace.x1 + freeSpace.width / 2 - this.width / 2;\r\n\r\n    top = freeSpace.y1;\r\n  } else if (this.verticalAlign === \"center\") {\r\n    if (this.horizontalAlign === \"left\")\r\n      left = freeSpace.x1;\r\n    else if (this.horizontalAlign === \"right\")\r\n      left = freeSpace.x2 - this.width;\r\n    else\r\n      left = freeSpace.x1 + freeSpace.width / 2 - this.width / 2;\r\n\r\n    top = freeSpace.y1 + freeSpace.height / 2 - this.height / 2;\r\n  } else if (this.verticalAlign === \"bottom\") {\r\n    if (this.horizontalAlign === \"left\")\r\n      left = freeSpace.x1;\r\n    else if (this.horizontalAlign === \"right\")\r\n      left = freeSpace.x2 - this.width;\r\n    else\r\n      left = freeSpace.x1 + freeSpace.width / 2 - this.width / 2;\r\n\r\n    top = freeSpace.y2 - this.height;\r\n  }\r\n\r\n  this.items = items;\r\n\r\n  //Assign ids to all legendItems\r\n  for (var i = 0; i < this.items.length; i++) {\r\n\r\n    var item = items[i];\r\n\r\n    item.id = ++this.chart._eventManager.lastObjectId;\r\n    this.chart._eventManager.objectMap[item.id] = {\r\n      id: item.id, objectType: \"legendItem\", legendItemIndex: i, dataSeriesIndex: item.dataSeriesIndex, dataPointIndex: item.dataPointIndex\r\n    };\r\n    //delete item.textBlock;// Not Required anymore\r\n  }\r\n\r\n  var rowHeight = 0;\r\n  for (var i = 0; i < rows.length; i++) {\r\n    var row = rows[i];\r\n    var columnHeight = 0;\r\n    for (var itemIndex = 0; itemIndex < row.items.length; itemIndex++) {\r\n      var item = row.items[itemIndex];\r\n\r\n      var itemX = item.textBlock.x + left + (itemIndex === 0 ? markerSize * .2 : this.horizontalSpacing);\r\n      var itemY = top + rowHeight;\r\n\r\n      var ghostX = itemX;\r\n\r\n      if (!this.chart.data[item.dataSeriesIndex].visible)\r\n        this.ctx.globalAlpha = .5;\r\n\r\n      this.ctx.save();\r\n      this.ctx.rect(left, top, maxWidth, maxHeight);\r\n      this.ctx.clip();\r\n\r\n      if (item.chartType === \"line\" || item.chartType === \"stepLine\" || item.chartType === \"spline\") {\r\n        this.ctx.strokeStyle = item.lineColor;\r\n        this.ctx.lineWidth = Math.ceil(this.lineHeight / 8);\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(itemX - this.lineHeight * .1, itemY + this.lineHeight / 2);\r\n        this.ctx.lineTo(itemX + this.lineHeight * .7, itemY + this.lineHeight / 2);\r\n        this.ctx.stroke();\r\n\r\n        ghostX -= this.lineHeight * .1;\r\n      }\r\n\r\n      RenderHelper.drawMarker(itemX + markerSize / 2, itemY + (this.lineHeight / 2), this.ctx, item.markerType, item.markerSize, item.markerColor, item.markerBorderColor, item.markerBorderThickness);\r\n\r\n      item.textBlock.x = itemX + this.horizontalSpacing * .1 + markerSize;\r\n\r\n      if (item.chartType === \"line\" || item.chartType === \"stepLine\" || item.chartType === \"spline\") {\r\n        item.textBlock.x = item.textBlock.x + this.lineHeight * .1;\r\n      }\r\n\r\n      item.textBlock.y = itemY;\r\n\r\n      item.textBlock.render(true);\r\n\r\n      this.ctx.restore();\r\n\r\n      if (itemIndex > 0) {\r\n        columnHeight = Math.max(columnHeight, item.textBlock.height);\r\n      } else {\r\n        columnHeight = item.textBlock.height;\r\n      }\r\n\r\n      if (!this.chart.data[item.dataSeriesIndex].visible)\r\n        this.ctx.globalAlpha = 1;\r\n\r\n      var hexColor = intToHexColorString(item.id);\r\n      this.ghostCtx.fillStyle = hexColor;\r\n      this.ghostCtx.beginPath();\r\n      this.ghostCtx.fillRect(ghostX, item.textBlock.y, item.textBlock.x + item.textBlock.width - ghostX, item.textBlock.height);\r\n\r\n      item.x1 = this.chart._eventManager.objectMap[item.id].x1 = ghostX;\r\n      item.y1 = this.chart._eventManager.objectMap[item.id].y1 = item.textBlock.y;\r\n      item.x2 = this.chart._eventManager.objectMap[item.id].x2 = item.textBlock.x + item.textBlock.width;\r\n      item.y2 = this.chart._eventManager.objectMap[item.id].y2 = item.textBlock.y + item.textBlock.height;\r\n    }\r\n    rowHeight = rowHeight + columnHeight;\r\n  }\r\n\r\n  //this.ctx.beginPath();\r\n  //this.ctx.lineWidth = 2;\r\n  //this.ctx.strokeStyle = \"red\";\r\n  //this.ctx.rect(left, top, this.width, this.height);\r\n  //this.ctx.stroke();\r\n\r\n  container.layoutManager.registerSpace(position, { width: this.width + 2 + 2, height: this.height + 5 + 5 });\r\n\r\n  this.bounds = {\r\n    x1: left, y1: top, x2: left + this.width, y2: top + this.height\r\n  };\r\n}\r\n\r\nexport default Legend;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}